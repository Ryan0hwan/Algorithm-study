https://www.notion.so/DFS-BFS-Backtracking-1d2d9fdf7d928000a2d8e212e87347f4?pvs=4
* DFS, BFS, 백트리킹 모두 완전탐색의 일종이다.

---

## 그래프

- Vertex(node)와 edge로 이루어짐.
- 방향그래프와 무방향그래프(양방향)가 있음.
- 순환그래프와 비순환그래프가 있다.

방향성 비순환 그래프(DAG, Direct Acyclic graph) 이 용어를 알아둬라.   깃같은 VCS들이 여기에 해당된다.

![이 그래프의 연결요소는 2  << 이렇게 표현한다.](attachment:6a69fdc9-37a2-4097-9fd2-b3cb6b8cd85c:image.png)

이 그래프의 연결요소는 2  << 이렇게 표현한다.

---

## 트리

| 수학에서의 트리 | 전산학에서의 트리 |
| --- | --- |
| 순환성 X, 방향성 X | 순환성 X, 방향성 O |
| 어떤 노드던 루트가 될 수 있음. | 한 노트가 루트 / 부모→자식 관계 존재 |
- 노드 A에서 노드 B로 가는 루트는 딱 1개로 유일하다.
- **edge의수 = node의수 + 1 [트리 확인 공식]**

---

## 코드로 그래프를 표현해보자.

- 그래프는 따로 모듈제공이 없어서. 구현을 해서 써야한다.
- **방법은 2가지** >>   **인접행렬(왼쪽) 과 인접리스트(오른쪽).**
- 인접행렬에서는 edge가 없는 부분에도 ‘0’으로 할당하는 반면, 인접리스트에서는 없는 부분은 신경도 안씀.
- 연결리스트의 경우, 파이썬에서는 주로 리스트로 구현함.

![image.png](attachment:305208c5-1ef6-41ba-b816-9ea5cd3aa7a1:image.png)

                                    

![image.png](attachment:26d9157a-324b-48e3-95e5-8c66494cd0ea:image.png)

 

- 그래프 문제를 보면, 조건을 보고 인접행렬과 인접리스트 중 뭘 사용할지 판단해야한다.
- 주로 시간복잡도를 따지기에, N의 크기를 보고 판단.
- N이 크면, 인접행렬이 유리, N이 작으면 인접리스트가 유리 / BUT, 일반적으로는 둘다 써도 상관없게 나옴.

| 인접행렬 [공간낭비, 시간아낌] | 인접리스트 [시간낭비, 공간아낌] |
| --- | --- |
| 없는 edge도 0으로 표현 → 공간을 무조건 n^2개만큼 쓴다 | 없는 edge 무시. |
| 임의접근이 가능하기에 탐색이 쉽지 | 임의접근이 불가하고, 다 돌면서 확인해야함. 
→ O(N) 전부다 확인하는거지 |
